"""
Transcription comparison functionality tests.

Consolidated from:
- test_js_parity.py (JavaScript parity testing)
- test_real_world.py (Real-world text comparison)

This reduces duplicate mode loading and provides better test organization.
"""

import pytest


# Use fixtures from conftest.py - no need to redefine them here


# Cache for parsed modes (from original test_js_parity.py)
_mode_cache = {}

def get_python_transcription(mode: str, text: str) -> str:
    """Get transcription from Python implementation."""
    if mode not in _mode_cache:
        from glaemscribe.parsers.mode_parser import ModeParser
        from glaemscribe.resources import get_mode_path
        parser = ModeParser()
        mode_file = get_mode_path(mode)
        mode_obj = parser.parse(str(mode_file))
        mode_obj.processor.finalize({})
        _mode_cache[mode] = mode_obj
    
    mode_obj = _mode_cache[mode]
    success, result, _ = mode_obj.transcribe(text)
    
    if not success:
        raise ValueError(f"Python transcription failed: {result}")
    
    return result


def analyze_transcription(text: str) -> dict:
    """Analyze transcription structure."""
    return {
        'length': len(text),
        'has_spaces': ' ' in text,
        'space_count': text.count(' '),
        'is_empty': len(text.strip()) == 0,
        'char_types': {
            'spaces': sum(1 for c in text if c == ' '),
            'unicode_pua': sum(1 for c in text if 0xE000 <= ord(c) <= 0xF8FF),
            'plane14_pua': sum(1 for c in text if 0xE0000 <= ord(c) <= 0xEFFFF),
            'ascii': sum(1 for c in text if ord(c) < 128),
            'other': sum(1 for c in text if ord(c) >= 128 and not (0xE000 <= ord(c) <= 0xF8FF) and not (0xE0000 <= ord(c) <= 0xEFFFF))
        }
    }


# Pre-generated reference outputs from JavaScript implementation
# Generated by: uv run python generate_reference_transcriptions.py
# Last updated: 2025-11-13
JS_REFERENCE_OUTPUTS = {
    ('quenya-tengwar-classical', 'Ai ! laurië lantar lassi súrinen ,'): {
        'result': 'lE Á j.E7T`V jE4#6 jE,T 8~M7T5$5 =',
        'length': 34
    },
    ('quenya-tengwar-classical', 'Elen síla lúmenn omentielvo'): {
        'result': '`VjR5 8~BjE j~Mt$5" `Nt$4%`VjyY',
        'length': 31
    },
    ('quenya-tengwar-classical', 'aiya'): {
        'result': 'lEhÍE',
        'length': 5
    },
}


def get_js_reference(mode: str, text: str) -> dict:
    """Get pre-generated reference transcription from JavaScript implementation."""
    key = (mode, text)
    if key not in JS_REFERENCE_OUTPUTS:
        pytest.skip(f"No JS reference output for: {mode} / {text}")
    
    ref = JS_REFERENCE_OUTPUTS[key]
    return {
        'success': True,
        'result': ref['result'],
        'length': ref['length']
    }


class TestJavaScriptParity:
    """Test Python implementation against JavaScript reference outputs."""
    
    def test_unicode_normalization(self, quenya_classical_mode):
        """Test that both implementations handle Unicode consistently."""
        mode = quenya_classical_mode
        
        # Test with various Unicode text
        test_texts = [
            "aiya",
            "Elen síla",
            "A Elbereth Gilthoniel",
        ]
        
        for text in test_texts:
            # Python transcription
            py_success, py_result, _ = mode.transcribe(text)
            assert py_success, f"Python transcription failed for '{text}'"
            
            # Basic checks
            assert isinstance(py_result, str)
            assert len(py_result) > 0
            
            # Should contain Tengwar characters
            analysis = analyze_transcription(py_result)
            assert analysis['char_types']['unicode_pua'] > 0 or analysis['char_types']['plane14_pua'] > 0
    
    def test_structural_parity_with_js(self):
        """Test structural parity with JavaScript implementation."""
        test_cases = [
            {
                'mode': 'quenya-tengwar-classical',
                'input': 'Ai ! laurië lantar lassi súrinen ,',
                'description': 'Quenya phrase - Namárië opening',
            },
            {
                'mode': 'quenya-tengwar-classical',
                'input': 'Elen síla lúmenn omentielvo',
                'description': 'Quenya greeting',
            },
            {
                'mode': 'quenya-tengwar-classical',
                'input': 'aiya',
                'description': 'Simple Quenya word',
            },
        ]
        
        for test_case in test_cases:
            mode_name = test_case['mode']
            input_text = test_case['input']
            
            # Get Python transcription
            py_output = get_python_transcription(mode_name, input_text)
            py_analysis = analyze_transcription(py_output)
            
            # Get JavaScript reference
            js_output = get_js_reference(mode_name, input_text)
            js_analysis = analyze_transcription(js_output['result'])
            
            # Compare structural properties
            length_diff = abs(js_analysis['length'] - py_analysis['length'])
            if js_analysis['length'] < 10:
                # For short strings, allow small absolute difference
                assert length_diff <= 2, f"Length difference too large for short string: JS={js_analysis['length']}, Python={py_analysis['length']}"
            else:
                # For longer strings, allow percentage difference
                length_diff_pct = length_diff / js_analysis['length'] * 100
                assert length_diff_pct <= 10, f"Length difference too large: JS={js_analysis['length']}, Python={py_analysis['length']} ({length_diff_pct:.1f}%)"
            
            # Both should have spaces if expected
            assert js_analysis['has_spaces'] == py_analysis['has_spaces'], f"Space presence mismatch: JS={js_analysis['has_spaces']}, Python={py_analysis['has_spaces']}"
            
            # Space count should be similar
            if js_analysis['has_spaces']:
                space_diff = abs(js_analysis['space_count'] - py_analysis['space_count'])
                assert space_diff <= 2, f"Space count difference too large: JS={js_analysis['space_count']}, Python={py_analysis['space_count']}"
    
    def test_expected_structure(self):
        """Test that transcriptions have expected structural properties."""
        test_cases = [
            {
                'mode': 'quenya-tengwar-classical',
                'input': 'Ai ! laurië lantar lassi súrinen ,',
                'expected_structure': {
                    'min_length': 30,
                    'has_spaces': True,
                    'min_space_count': 5
                }
            },
            {
                'mode': 'quenya-tengwar-classical',
                'input': 'Elen síla lúmenn omentielvo',
                'expected_structure': {
                    'min_length': 25,
                    'has_spaces': True,
                    'min_space_count': 3
                }
            },
            {
                'mode': 'quenya-tengwar-classical',
                'input': 'aiya',
                'expected_structure': {
                    'min_length': 3,
                    'has_spaces': False,
                    'min_space_count': 0
                }
            },
        ]
        
        for test_case in test_cases:
            mode_name = test_case['mode']
            input_text = test_case['input']
            expected = test_case['expected_structure']
            
            # Get Python transcription
            py_output = get_python_transcription(mode_name, input_text)
            py_analysis = analyze_transcription(py_output)
            
            # Check structure
            assert py_analysis['length'] >= expected['min_length'], f"Output too short: {py_analysis['length']} < {expected['min_length']}"
            assert py_analysis['has_spaces'] == expected['has_spaces'], f"Space presence unexpected: {py_analysis['has_spaces']}"
            assert py_analysis['space_count'] >= expected['min_space_count'], f"Too few spaces: {py_analysis['space_count']} < {expected['min_space_count']}"
            
            # Should contain Tengwar characters
            assert py_analysis['char_types']['unicode_pua'] > 0 or py_analysis['char_types']['plane14_pua'] > 0, "No Tengwar characters found in output"


class TestRealWorldTranscription:
    """Test transcription with real-world Tolkien texts."""
    
    @pytest.mark.real_world
    def test_real_world_quenya_transcription(self, quenya_classical_mode):
        """Test transcription of real-world Quenya texts."""
        mode = quenya_classical_mode
        test_cases = [
            {
                'input': 'Elen síla lúmenn omentielvo',
                'description': 'Famous Quenya phrase from LOTR'
            },
        ]
        
        for test_case in test_cases:
            input_text = test_case['input']
            
            # Transcribe the text
            success, result, debug = mode.transcribe(input_text)
            
            assert success, f"Transcription failed for {test_case['description']}: {result}"
            assert isinstance(result, str)
            assert len(result) > 0
            
            # Analyze the result
            analysis = analyze_transcription(result)
            
            # Should contain Tengwar characters
            assert analysis['char_types']['unicode_pua'] > 0 or analysis['char_types']['plane14_pua'] > 0, f"No Tengwar characters in: {result}"
            
            print(f"✓ {test_case['description']}: '{input_text}' → '{result}' ({len(result)} chars)")
    
    @pytest.mark.real_world
    def test_tengwar_unicode_ranges(self, quenya_classical_mode):
        """Test that real-world transcriptions use appropriate Unicode ranges."""
        mode = quenya_classical_mode
        
        # Test various real-world texts
        test_texts = [
            "Elen síla lúmenn omentielvo",
            "Ai ! laurië lantar lassi súrinen",
            "A Elbereth Gilthoniel",
            "namárië",
            "aiya"
        ]
        
        for text in test_texts:
            success, result, _ = mode.transcribe(text)
            assert success, f"Transcription failed for: {text}"
            
            # Check Unicode ranges used
            for char in result:
                char_code = ord(char)
                
                # Should be in valid ranges
                is_valid = (
                    (0xE000 <= char_code <= 0xF8FF) or  # BMP Private Use Area
                    (0xE0000 <= char_code <= 0xEFFFF) or  # Plane 14 Private Use Area
                    (char_code == 0x0020) or  # Space
                    (0x0021 <= char_code <= 0x007F)  # Basic Latin
                )
                
                assert is_valid, f"Invalid character {char:04X} in transcription of '{text}'"
    
    @pytest.mark.real_world
    def test_transcription_consistency(self, quenya_classical_mode):
        """Test that transcriptions are consistent across multiple runs."""
        mode = quenya_classical_mode
        
        test_text = "Elen síla lúmenn omentielvo"
        
        # Transcribe the same text multiple times
        results = []
        for i in range(5):
            success, result, _ = mode.transcribe(test_text)
            assert success, f"Transcription failed on run {i+1}"
            results.append(result)
        
        # All results should be identical
        assert all(r == results[0] for r in results), "Inconsistent transcription results"
        
        print(f"✓ Consistent transcription: '{test_text}' → '{results[0]}'")
    
    @pytest.mark.real_world
    def test_large_text_transcription(self, quenya_classical_mode):
        """Test transcription of larger texts."""
        mode = quenya_classical_mode
        
        # Create a larger text by repeating a phrase
        base_phrase = "Elen síla lúmenn omentielvo"
        large_text = f"{base_phrase}. {base_phrase} Aiya elenion ancalima!"
        
        success, result, _ = mode.transcribe(large_text)
        
        assert success, "Large text transcription failed"
        assert isinstance(result, str)
        assert len(result) > len(base_phrase) * 2  # Should be longer than base phrase
        
        # Analyze the result
        analysis = analyze_transcription(result)
        
        # Should contain plenty of Tengwar characters
        assert analysis['char_types']['unicode_pua'] > 10 or analysis['char_types']['plane14_pua'] > 10, "Large text should contain many Tengwar characters"
        
        print(f"✓ Large text transcription: {len(large_text)} chars → {len(result)} chars")


class TestTranscriptionQuality:
    """Test transcription quality and characteristics."""
    
    def test_character_distribution(self, quenya_classical_mode):
        """Test that transcriptions have reasonable character distribution."""
        mode = quenya_classical_mode
        
        test_texts = [
            "aiya",
            "Elen síla lúmenn omentielvo",
            "Ai ! laurië lantar lassi súrinen"
        ]
        
        for text in test_texts:
            success, result, _ = mode.transcribe(text)
            assert success, f"Transcription failed for: {text}"
            
            analysis = analyze_transcription(result)
            
            # Should have reasonable character distribution
            total_chars = len(result)
            tengwar_chars = analysis['char_types']['unicode_pua'] + analysis['char_types']['plane14_pua']
            
            # Most characters should be Tengwar (except spaces)
            if total_chars > 0:
                tengwar_ratio = tengwar_chars / total_chars
                assert tengwar_ratio > 0.5, f"Too few Tengwar characters: {tengwar_chars}/{total_chars} ({tengwar_ratio:.1%})"
    
    def test_no_fallback_characters(self, quenya_classical_mode):
        """Test that transcriptions don't contain fallback characters."""
        mode = quenya_classical_mode
        
        test_texts = [
            "aiya",
            "mellon",
            "elen"
        ]
        
        for text in test_texts:
            success, result, _ = mode.transcribe(text)
            assert success, f"Transcription failed for: {text}"
            
            # Should not contain fallback '?' characters
            assert '?' not in result, f"Found fallback character in transcription of '{text}': {result}"
    
    def test_transcription_reproducibility(self, sindarin_general_mode):
        """Test that transcriptions are reproducible."""
        mode = sindarin_general_mode
        
        test_text = "mellon"
        
        # Multiple transcriptions should yield identical results
        results = []
        for i in range(10):
            success, result, _ = mode.transcribe(test_text)
            assert success, f"Transcription failed on iteration {i}"
            results.append(result)
        
        # All results should be identical
        unique_results = set(results)
        assert len(unique_results) == 1, f"Non-reproducible results: {unique_results}"
